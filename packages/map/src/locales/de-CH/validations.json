{
  "any.unknown": "ist nicht erlaubt",
  "any.invalid": "hat einen ungültigen Wert",
  "any.empty": "darf nicht leer sein",
  "any.required": "ist erforderlich",
  "any.allowOnly": "muss eines von {{valids}} sein",
  "any.default": "Beim Ausführen der Standardmethode ist ein Fehler aufgetreten",
  "alternatives.base": "stimmt mit keiner der zulässigen Alternativen überein",
  "array.base": "muss ein Array sein",
  "array.includes": "an Position {{pos}} entspricht der Wert nicht den zulässigen Typen",
  "array.includesSingle": "Einzelwert von \"{{!label}}\" entspricht nicht den zulässigen Typen",
  "array.includesOne": "an Position {{pos}} schlägt es fehl, weil {{reason}}",
  "array.includesOneSingle": "Einzelwert von \"{{!label}}\" schlägt fehl, weil {{reason}}",
  "array.includesRequiredUnknowns": "enthält die {{unknownMisses}} erforderlichen Werte nicht",
  "array.includesRequiredKnowns": "enthält {{knownMisses}} nicht",
  "array.includesRequiredBoth": "enthält {{knownMisses}} und {{unknownMisses}} weitere erforderliche Werte nicht",
  "array.excludes": "an Position {{pos}} ist ein ausgeschlossener Wert enthalten",
  "array.excludesSingle": "Einzelwert von \"{{!label}}\" ist ein ausgeschlossener Wert",
  "array.min": "muss mindestens {{limit}} Elemente enthalten",
  "array.max": "muss weniger als oder gleich {{limit}} Elemente enthalten",
  "array.length": "muss {{limit}} Elemente enthalten",
  "array.ordered": "an Position {{pos}} schlägt die Prüfung fehl: {{reason}}",
  "array.orderedLength": "an der Position {{pos}} schlägt es fehl, weil das Array höchstens {{limit}} Elemente enthalten darf",
  "array.ref": "verweist auf \"{{ref}}\", das keine positive Ganzzahl ist",
  "array.sparse": "darf kein Array mit Nullwerten sein",
  "array.unique": "an Position {{pos}} befindet sich ein doppelter Wert",
  "boolean.base": "muss ein boolescher Wert sein",
  "binary.base": "muss ein Puffer oder eine Zeichenkette sein",
  "binary.min": "muss mindestens {{limit}} Bytes groß sein",
  "binary.max": "muss höchstens {{limit}} Bytes groß sein",
  "binary.length": "muss genau {{limit}} Bytes groß sein",
  "date.base": "muss eine Anzahl von Millisekunden oder eine gültige Datumszeichenfolge sein",
  "date.format": "muss eine Zeichenkette mit einem der folgenden Formate sein: {{format}}",
  "date.strict": "muss ein gültiges Datum sein",
  "date.min": "muss größer oder gleich \"{{limit}}\" sein",
  "date.max": "muss kleiner oder gleich \"{{limit}}\" sein",
  "date.isoDate": "muss ein gültiges ISO 8601-Datum sein",
  "date.timestamp.javascript": "muss einen gültigen Zeitstempel oder eine Anzahl von Millisekunden darstellen",
  "date.timestamp.unix": "muss einen gültigen Zeitstempel oder die Anzahl der Sekunden darstellen",
  "date.ref": "referenziert \"{{ref}}\", das kein Datum ist",
  "function.base": "muss eine Funktion sein",
  "function.arity": "muss genau {{n}} Parameter haben",
  "function.minArity": "muss mindestens {{n}} Parameter haben",
  "function.maxArity": "muss höchstens {{n}} Parameter haben",
  "function.ref": "muss eine Joi-Referenz sein",
  "function.class": "muss eine Klasse sein",
  "lazy.base": "!!Schemafehler: Lazy-Schema muss festgelegt werden",
  "lazy.schema": "!!Schemafehler: Lazy-Schema-Funktion muss ein Schema zurückgeben",
  "object.base": "muss ein Objekt sein",
  "object.child": "Feld \"{{!label}}\" schlägt fehl, weil {{reason}}",
  "object.min": "muss mindestens {{limit}} Eigenschaften haben",
  "object.max": "muss höchstens {{limit}} Eigenschaften enthalten",
  "object.length": "muss genau {{limit}} Eigenschaften enthalten",
  "object.allowUnknown": "!!\"{{!child}}\" ist nicht erlaubt",
  "object.with": "!!\"{{mainWithLabel}}\" erfordert den Peer \"{{peerWithLabel}}\"",
  "object.without": "!!\"{{mainWithLabel}}\" steht im Konflikt mit dem verbotenen Peer \"{{peerWithLabel}}\"",
  "object.missing": "muss mindestens einen von {{peersWithLabels}} enthalten",
  "object.xor": "enthält einen Konflikt zwischen exklusiven Peers {{peersWithLabels}}",
  "object.or": "muss mindestens einen von {{peersWithLabels}} enthalten",
  "object.and": "enthält {{presentWithLabels}}, ohne die erforderlichen Peers {{missingWithLabels}}",
  "object.nand": "!!\"{{mainWithLabel}}\" darf nicht gleichzeitig mit {{peersWithLabels}} existieren",
  "object.assert": "!!Überprüfung von \"{{ref}}\" fehlgeschlagen: {{message}}",
  "object.rename.multiple": "kann das Kind \"{{from}}\" nicht umbenennen, da mehrere Umbenennungen deaktiviert sind und ein anderer Schlüssel bereits in \"{{to}}\" umbenannt wurde",
  "object.rename.override": "kann das Kind \"{{from}}\" nicht umbenennen, weil das Überschreiben deaktiviert ist und das Ziel \"{{to}}\" existiert",
  "object.rename.regex.multiple": "kann das Kind \"{{from}}\" nicht umbenennen, da mehrere Umbenennungen deaktiviert sind und ein anderer Schlüssel bereits in \"{{to}}\" umbenannt wurde",
  "object.rename.regex.override": "kann das Kind \"{{from}}\" nicht umbenennen, weil das Überschreiben deaktiviert ist und das Ziel \"{{to}}\" existiert",
  "object.type": "muss ein \"{{type}}\" sein",
  "object.schema": "muss ein Joi-Schema sein",
  "number.base": "muss eine Zahl sein",
  "number.min": "muss größer oder gleich {{limit}} sein",
  "number.max": "muss kleiner oder gleich {{limit}} sein",
  "number.less": "muss kleiner als {{limit}} sein",
  "number.greater": "muss größer als {{limit}} sein",
  "number.float": "muss ein Float oder Double sein",
  "number.integer": "muss ein Integer sein",
  "number.negative": "muss eine negative Zahl sein",
  "number.positive": "muss eine positive Zahl sein",
  "number.precision": "darf nicht mehr als {{limit}} Dezimalstellen haben",
  "number.ref": "referenziert \"{{ref}}\", das keine Zahl ist",
  "number.multiple": "muss ein Vielfaches von {{multiple}} sein",
  "number.port": "muss ein gültiger Port sein",
  "number.map": "muss eine Zahl oder einer der Werte aus {{enums}} sein",
  "string.base": "muss eine Zeichenkette sein",
  "string.min": "muss mindestens {{limit}} Zeichen lang sein",
  "string.max": "muss höchstens {{limit}} Zeichen lang sein",
  "string.length": "muss genau {{limit}} Zeichen lang sein",
  "string.alphanum": "darf nur alphanumerische Zeichen enthalten",
  "string.token": "darf nur alphanumerische Zeichen und Unterstriche enthalten",
  "string.regex.base": "mit dem Wert \"{{!value}}\" stimmt es nicht mit dem erforderlichen Muster überein: {{pattern}}",
  "string.regex.name": "mit dem Wert \"{{!value}}\" stimmt es nicht mit dem Muster {{name}} überein",
  "string.regex.invert.base": "mit dem Wert \"{{!value}}\" stimmt es nicht mit dem erforderlichen Muster überein: {{pattern}}",
  "string.regex.invert.name": "mit dem Wert \"{{!value}}\" stimmt es nicht mit dem Muster {{name}} überein",
  "string.email": "muss eine gültige E-Mail-Adresse sein",
  "string.uri": "muss eine gültige URI sein",
  "string.uriRelativeOnly": "muss eine gültige relative URI sein",
  "string.uriCustomScheme": "muss eine gültige URI mit einem Schema sein, das dem Muster {{scheme}} entspricht",
  "string.isoDate": "muss ein gültiges ISO 8601-Datum sein",
  "string.guid": "muss eine gültige GUID sein",
  "string.hex": "darf nur hexadezimale Zeichen enthalten",
  "string.hexAlign": "Hex-Darstellung muss byte-ausgerichtet sein",
  "string.base64": "muss ein gültiger Base64-String sein",
  "string.hostname": "muss ein gültiger Hostname sein",
  "string.normalize": "muss in der Unicode-Normalform {{form}} vorliegen",
  "string.lowercase": "darf nur Kleinbuchstaben enthalten",
  "string.uppercase": "darf nur Großbuchstaben enthalten",
  "string.trim": "darf keine führenden oder nachgestellten Leerzeichen enthalten",
  "string.creditCard": "muss eine gültige Kreditkartennummer sein",
  "string.ref": "referenziert \"{{ref}}\", das keine Zahl ist",
  "string.ip": "muss eine gültige IP-Adresse mit CIDR {{cidr}} sein",
  "string.ipVersion": "muss eine gültige IP-Adresse sein, die mit einer der folgenden Versionen {{version}} und CIDR {{cidr}} übereinstimmt"
}
