{
  "any.unknown": "ist nicht erlaubt",
  "any.invalid": "ist einen ungültigen Wert",
  "any.empty": "darf nicht leer sein",
  "any.required": "ist obligatorisch",
  "any.allowOnly": "muss eins von {{valids}} sein",
  "any.default": "beim Ausführen der Standardmethode ist ein Fehler aufgetreten",
  "alternatives.base": "stimmt nicht mit einer der zulässigen Alternativen überein",
  "array.base": "muss eine Liste sein",
  "array.includes": "an der Position {{pos}} passt es nicht zu den zulässigen Typen",
  "array.includesSingle": "einzelwert von \"{{!label}}\" passt nicht zu den zulässigen Typen",
  "array.includesOne": "an der Position {{pos}} scheitert weil {{reason}}",
  "array.includesOneSingle": "einzelwert von \"{{!label}}\" scheitert weil {{reason}}",
  "array.includesRequiredUnknowns": "beinhaltet keine {{unknownMisses}} erforderliche Wert(e)",
  "array.includesRequiredKnowns": "beinhaltet nicht {{knownMisses}}",
  "array.includesRequiredBoth": "beinhaltet nicht {{knownMisses}} und {{unknownMisses}} weitere erforderliche Wert(e)",
  "array.excludes": "an der Position {{pos}} enthält einen ausgeschlossenen Wert",
  "array.excludesSingle": "einzelwert von \"{{!label}}\" enthält einen ausgeschlossenen Wert",
  "array.min": "muss mindestens {{limit}} Elemente enthalten",
  "array.max": "muss weniger als oder gleich {{limit}} Elemente enthalten",
  "array.length": "muss {{limit}} Elemente enthalten",
  "array.ordered": "an der Position {{pos}} schlägt es fehl, weil {{reason}}",
  "array.orderedLength": "an der Position {{pos}} schlägt es fehl, weil das Array höchstens {{limit}} Elemente enthalten darf",
  "array.ref": "referenzen \"{{ref}}\" die nicht eine positive ganzzahl",
  "array.sparse": "darf kein Array mit Nullwerten sein",
  "array.unique": "die Position {{pos}} enthält einen doppelten Wert",
  "boolean.base": "muss ein Boolean sein",
  "binary.base": "muss ein Buffer oder String sein",
  "binary.min": "muss mindestes {{limit}} Bytes sein",
  "binary.max": "muss weniger oder gleich {{limit}} Bytes sein",
  "binary.length": "muss {{limit}} Bytes sein",
  "date.base": "muss eine Anzahl von Millisekunden oder eine gültige Datumszeichenfolge sein",
  "date.format": "muss eine string mit einer der folgenden formate {{format}}",
  "date.strict": "muss eine gültiges datum",
  "date.min": "muss größer oder gleich \"{{limit}}\" sein",
  "date.max": "must be less than or equal to \"{{limit}}\"",
  "date.isoDate": "muss ein gültiges ISO 8601-Datum sein",
  "date.timestamp.javascript": "muss einen gültigen timestamp oder anzahl millisekunden",
  "date.timestamp.unix": "muss einen gültigen timestamp oder die anzahl der sekunden",
  "date.ref": "referenziert \"{{ref}}\" was kein Datum ist",
  "function.base": "muss eine Function sein",
  "function.arity": "muss ein sondern von {{n}}",
  "function.minArity": "muss ein sondern größer oder gleich {{n}}",
  "function.maxArity": "muss ein sondern weniger oder gleich {{n}}",
  "function.ref": "muss ein joi - bezug",
  "function.class": "muss eine klasse",
  "lazy.base": "!!schema fehler: faule schema festgelegt werden müssen,",
  "lazy.schema": "!!schema fehler: faule schema funktion muss wieder ein schema",
  "object.base": "muss ein Object sein",
  "object.child": "Kind \"{{!label}}\" scheitert weil {{reason}}",
  "object.min": "muss mindestens {{limit}} Kinder haben",
  "object.max": "muss weniger oder gleich {{limit}} Kinder enthalten",
  "object.length": "muss {{limit}} Kinder enthalten",
  "object.allowUnknown": "!!\"{{!child}}\" ist nicht erlaubt",
  "object.with": "!!\"{{mainWithLabel}}\" fehlender erforderlicher Peer \"{{peerWithLabel}}\"",
  "object.without": "!!\"{{mainWithLabel}}\" Konflikt mit verbotenen Peer \"{{peerWithLabel}}\"",
  "object.missing": "muss mindestens einen von {{peersWithLabels}} enthalten",
  "object.xor": "enthält einen Konflikt zwischen exklusiven Peers {{peersWithLabels}}",
  "object.or": "muss mindestens einen von {{peersWithLabels}} enthalten",
  "object.and": "enthält {{presentWithLabels}} ohne folgende erforderlichen Peers {{missingWithLabels}}",
  "object.nand": "!!\"{{mainWithLabel}}\" darf nicht gleichzeitig mit {{peersWithLabels}} existieren",
  "object.assert": "!!\"{{ref}}\" Validierung fehlgeschlagen, weil \"{{ref}}\" {{message}} fehlgeschlagen ist",
  "object.rename.multiple": "kann das Kind \"{{from}}\" nicht umbenennen, da mehrere Umbenennungen deaktiviert sind und ein anderer Schlüssel bereits in \"{{to}}\" umbenannt wurde",
  "object.rename.override": "kann das Kind \"{{from}}\" nicht umbenennen, weil das Überschreiben deaktiviert ist und das Ziel \"{{to}}\" existiert",
  "object.rename.regex.multiple": "kann das Kind \"{{from}}\" nicht umbenennen, da mehrere Umbenennungen deaktiviert sind und ein anderer Schlüssel bereits in \"{{to}}\" umbenannt wurde",
  "object.rename.regex.override": "kann das Kind \"{{from}}\" nicht umbenennen, weil das Überschreiben deaktiviert ist und das Ziel \"{{to}}\" existiert",
  "object.type": "muss ein \"{{type}}\" sein",
  "object.schema": "muss ein Joi beispiel",
  "number.base": "muss eine Number sein",
  "number.min": "muss größer oder gleich {{limit}} sein",
  "number.max": "muss kleiner oder gleich {{limit}} sein",
  "number.less": "muss kleiner als {{limit}} sein",
  "number.greater": "muss größer als {{limit}} sein",
  "number.float": "muss ein Float oder Double sein",
  "number.integer": "muss ein Integer sein",
  "number.negative": "muss eine negative Zahl sein",
  "number.positive": "muss eine positive Zahl sein",
  "number.precision": "darf nicht mehr als {{limit}} Dezimalstellen haben",
  "number.ref": "referenziert \"{{ref}}\" was keine Number ist",
  "number.multiple": "muss ein Vielfaches von {{multiple}} sein",
  "number.port": "muss ein gültiger hafen",
  "number.map": "muss eine zahl oder eine {{enums}}",
  "string.base": "muss ein String sein",
  "string.min": "Länge muss mindestens {{limit}} Zeichen lang sein",
  "string.max": "Länge muss weniger oder gliech {{limit}} Zeichen lang sein",
  "string.length": "Länge muss {{limit}} Zeichen lang sein",
  "string.alphanum": "darf nur alphanumerische Zeichen enthalten",
  "string.token": "darf nur alphanumerische Zeichen und Unterstriche enthalten",
  "string.regex.base": "mit Wert \"{{!value}}\" stimt es nicht mit dem erforderlichen Muster überein: {{pattern}}",
  "string.regex.name": "mit Wert \"{{!value}}\" stimt es nicht mit dem {{name}} Muster überein",
  "string.regex.invert.base": "mit Wert \"{{!value}}\" stimt es nicht mit dem erforderlichen Muster überein: {{pattern}}",
  "string.regex.invert.name": "mit Wert \"{{!value}}\" stimt es nicht mit dem {{name}} Muster überein",
  "string.email": "muss eine valide Email sein",
  "string.uri": "muss eine valide URI sein",
  "string.uriRelativeOnly": "muss ein gültiger relative uri",
  "string.uriCustomScheme": "muss eine valide URI sein mit einem Schema, dass mit dem {{scheme}} Muster übereinstimmt",
  "string.isoDate": "muss ein gültiges ISO 8601-Datum sein",
  "string.guid": "muss eine valide GUID sein",
  "string.hex": "darf nur hexadezimale Zeichen enthalten",
  "string.hexAlign": "hex vertretung muss byte angepasst",
  "string.base64": "muss ein gültiger base64 - string",
  "string.hostname": "muss ein gültiger Hostname sein",
  "string.normalize": "muss unicode normalisierten in der {{form}} form",
  "string.lowercase": "darf nur Kleinbuchstaben enthalten",
  "string.uppercase": "darf nur Großbuchstaben enthalten",
  "string.trim": "darf keine führenden oder nachgestellten Leerzeichen enthalten",
  "string.creditCard": "muss eine Kreditkarte sein",
  "string.ref": "referenziert \"{{ref}}\", was keine nummer ist",
  "string.ip": "muss eine gültige IP-Adresse mit einer {{cidr}} CIDR sein",
  "string.ipVersion": "muss eine gültige IP-Adresse sein die mit einer der folgenden Versionen {{version}} und {{cidr}} CIDR übereinstimmt"
}
